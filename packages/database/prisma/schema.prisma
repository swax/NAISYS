// Multi-Machine Sync Notes (see docs/multi-machine-plan.md):
// - Each host should only insert/update rows where `host_id` matches its own host
// - Sync queries filter by `host_id`, so cross-host writes won't propagate correctly
// - `updated_at` fields are used to sync data between NAISYS runners and the hub
// - When the hub receives records from runners, it resets `updated_at` to its own timestamp
// - This ensures "stale" records from late-joining runners are properly synced to other machines
// - Catch-up queries use the hub's `updated_at` (not the original timestamp) to find missed records

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model context_log {
  id          String      @id // ULID
  user_id     String
  run_id      Int
  session_id  Int
  host_id     String? // Which host generated this log
  role        String
  source      String
  type        String
  message     String
  created_at  DateTime    @default(now())
  updated_at  DateTime    @updatedAt
  users       users       @relation("context_log_user", fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  run_session run_session @relation(fields: [user_id, run_id, session_id], references: [user_id, run_id, session_id], onDelete: NoAction, onUpdate: NoAction)
  host        hosts?      @relation(fields: [host_id], references: [host_id])

  @@index([id(sort: Desc)], map: "idx_context_log_id_desc") // ORDER BY id DESC in runsService.getContextLog
  @@index([user_id, run_id, session_id], map: "idx_context_log_run_session") // WHERE user_id, run_id, session_id in runsService.getContextLog
  @@index([host_id, id], map: "idx_context_log_sync") // Append-only sync: WHERE host_id = X AND id > Y ORDER BY id
}

model costs {
  id                 String      @id // ULID
  user_id            String
  run_id             Int
  session_id         Int
  host_id            String? // Which host incurred this cost
  source             String
  model              String
  cost               Float?      @default(0)
  input_tokens       Int?        @default(0)
  output_tokens      Int?        @default(0)
  cache_write_tokens Int?        @default(0)
  cache_read_tokens  Int?        @default(0)
  created_at         DateTime    @default(now())
  updated_at         DateTime    @updatedAt
  users              users       @relation("costs_user", fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  run_session        run_session @relation(fields: [user_id, run_id, session_id], references: [user_id, run_id, session_id], onDelete: NoAction, onUpdate: NoAction)
  host               hosts?      @relation(fields: [host_id], references: [host_id])

  @@index([id(sort: Desc)], map: "idx_costs_id_desc") // ORDER BY id DESC in costTracker.findFirst for aggregation window check
  @@index([user_id], map: "idx_costs_user_id") // Optional WHERE user_id filter in aggregate/groupBy queries
  @@index([user_id, run_id, session_id, source, model], map: "idx_costs_aggregation_key") // Cost aggregation lookups in costTracker
  @@index([host_id, updated_at], map: "idx_costs_sync") // Sync: WHERE host_id = X AND updated_at > Y ORDER BY updated_at
}

model mail_messages {
  id           String            @id // ULID
  from_user_id String
  host_id      String? // Sender's host
  subject      String
  body         String
  created_at   DateTime          @default(now())
  updated_at   DateTime          @updatedAt
  from_user    users             @relation("mail_messages_from_user", fields: [from_user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  host         hosts?            @relation(fields: [host_id], references: [host_id])
  recipients   mail_recipients[]
  status       mail_status[]

  @@index([id(sort: Desc)], map: "idx_mail_messages_id_desc") // ORDER BY id DESC in supervisor mailService pagination
  @@index([from_user_id], map: "idx_mail_messages_from_user_id") // WHERE from_user_id in sent messages filter
  @@index([created_at(sort: Desc)], map: "idx_mail_messages_created_at") // ORDER BY created_at DESC in llmail.listMessages and searchMessages
  @@index([host_id, id], map: "idx_mail_messages_sync") // Append-only sync: WHERE host_id = X AND id > Y ORDER BY id
  @@index([updated_at], map: "idx_mail_messages_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
}

model mail_recipients {
  id         String        @id // ULID
  message_id String
  user_id    String
  host_id    String? // Sender's host (same as message)
  type       String // "to", "cc", "bcc"
  created_at DateTime      @default(now())
  updated_at DateTime      @updatedAt
  message    mail_messages @relation(fields: [message_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user       users         @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  host       hosts?        @relation(fields: [host_id], references: [host_id])

  @@index([message_id], map: "idx_mail_recipients_message_id") // JOIN from mail_messages includes
  @@index([user_id, message_id(sort: Desc)], map: "idx_mail_recipients_user_id") // groupBy user_id + MAX(message_id) in supervisor agentService, also recipients.some({ user_id })
  @@index([host_id, id], map: "idx_mail_recipients_sync") // Append-only sync: WHERE host_id = X AND id > Y ORDER BY id
  @@index([updated_at], map: "idx_mail_recipients_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
}

model mail_status {
  id          String        @id // ULID
  message_id  String
  user_id     String
  host_id     String? // Recipient's host
  read_at     DateTime?
  archived_at DateTime?
  created_at  DateTime      @default(now())
  updated_at  DateTime      @updatedAt
  message     mail_messages @relation(fields: [message_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user        users         @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  host        hosts?        @relation(fields: [host_id], references: [host_id])

  @@unique([message_id, user_id], map: "unq_mail_status_message_user") // findUnique by message+user, one status per user per message
  @@index([user_id], map: "idx_mail_status_user_id") // Subquery: status.none({ user_id, read_at/archived_at }) in mail queries
  @@index([host_id, updated_at], map: "idx_mail_status_sync") // Sync: WHERE host_id = X AND updated_at > Y ORDER BY updated_at
  @@index([updated_at], map: "idx_mail_status_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
}

model users {
  id                 String              @id // ULID
  username           String
  title              String
  agent_path         String              @unique(map: "unq_users_agent_path")
  lead_username      String?
  config             String              @default("{}")
  host_id            String?
  created_at         DateTime            @default(now())
  updated_at         DateTime            @updatedAt
  deleted_at         DateTime?           // Soft delete for deactivated agents
  host               hosts?              @relation(fields: [host_id], references: [host_id])
  mail_messages_sent mail_messages[]     @relation("mail_messages_from_user")
  mail_recipients    mail_recipients[]
  mail_status        mail_status[]
  run_sessions       run_session[]
  context_logs       context_log[]       @relation("context_log_user")
  costs              costs[]             @relation("costs_user")
  user_notifications user_notifications?

  @@unique([username, host_id], map: "unq_users_username_host") // Same username can exist on different hosts
  @@index([host_id, updated_at], map: "idx_users_sync") // Sync: WHERE host_id = X AND updated_at > Y ORDER BY updated_at
  @@index([updated_at], map: "idx_users_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
  @@index([lead_username, host_id], map: "idx_users_lead_lookup") // WHERE lead_username, host_id in subagent.getSubAgents
}

model user_notifications {
  user_id       String    @id
  host_id       String? // Same as user's host
  latest_log_id String    @default("")
  /**
   * Not the same as modified date, for example an agent can receive mail while not being active
   */
  last_active    DateTime?
  updated_at     DateTime  @updatedAt
  users          users     @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  host           hosts?    @relation(fields: [host_id], references: [host_id])

  @@index([host_id, updated_at], map: "idx_user_notifications_sync") // Sync: WHERE host_id = X AND updated_at > Y ORDER BY updated_at
  @@index([updated_at], map: "idx_user_notifications_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
}

model run_session {
  user_id       String
  run_id        Int
  session_id    Int
  host_id       String? // Which host ran this session
  last_active   DateTime
  model_name    String
  latest_log_id String        @default("")
  total_lines   Int           @default(0)
  total_cost    Float         @default(0)
  created_at    DateTime      @default(now())
  updated_at    DateTime      @updatedAt
  users         users         @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  host          hosts?        @relation(fields: [host_id], references: [host_id])
  context_logs  context_log[]
  costs         costs[]

  @@id([user_id, run_id, session_id])
  @@index([user_id, last_active(sort: Desc)], map: "idx_run_session_user_active") // WHERE user_id ORDER BY last_active DESC in supervisor runsService pagination
  @@index([host_id, updated_at], map: "idx_run_session_sync") // Sync: WHERE host_id = X AND updated_at > Y ORDER BY updated_at
}

model schema_version {
  id      Int      @id @default(1)
  version Int      @unique(map: "unq_schema_version_version")
  updated DateTime
}

model hosts {
  host_id            String               @id @map("host_id") // ULID - same column name as FK in other tables
  name               String               @unique(map: "unq_hosts_name") // NAISYS_HOSTNAME
  created_at         DateTime             @default(now())
  updated_at         DateTime             @updatedAt
  users              users[]
  user_notifications user_notifications[]
  mail_messages      mail_messages[]
  mail_recipients    mail_recipients[]
  mail_status        mail_status[]
  run_sessions       run_session[]
  costs              costs[]
  context_logs       context_log[]

  @@index([updated_at], map: "idx_hosts_updated_at") // Catch-up: WHERE updated_at > Y AND host_id != X ORDER BY updated_at
}

model hub_sync_state {
  id              String   @id // Hub: remote runner's host_id. Runner: hub URL hash
  since_timestamp String // ISO timestamp of last synced data
  updated_at      DateTime @updatedAt
}
